import com.google.flatbuffers.ByteBufferUtil;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.UnionVector;

import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.util.Objects;

import MyGame.Example.Any;
import MyGame.Example.ArrayStruct;
import MyGame.Example.ArrayTable;
import MyGame.Example.Color;
import MyGame.Example.Monster;
import MyGame.Example.NestedStruct;
import MyGame.Example.Test;
import MyGame.Example.TestEnum;
import MyGame.Example.Vec3;
import NamespaceA.NamespaceB.TableInNestedNS;
import NamespaceA.TableInFirstNS;

import static com.google.flatbuffers.Constants.SIZE_PREFIX_LENGTH;

/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


@RunWith(JUnit4.class)
public class FlatbuffersTest {

  static byte[] data;

  @BeforeClass
  public static void setup() throws IOException {
    ClassLoader classLoader = FlatbuffersTest.class.getClassLoader();
    File file = new File(Objects.requireNonNull(classLoader.getResource("monsterdata_test.mon")).getFile());
    RandomAccessFile f;
    f = new RandomAccessFile(file, "r");
    data = new byte[(int) f.length()];
    f.readFully(data);
    f.close();
  }

  @org.junit.Test
  public void testMonsterBuffer() {
    // First, let's test reading a FlatBuffer generated by C++ code:
    // This file was generated from monsterdata_test.json
    testMonsterBuffer(ByteBuffer.wrap(data));
  }

  @org.junit.Test
  public void testNamespaceNesting() {
    // reference / manipulate these to verify compilation
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);

    TableInNestedNS.startTableInNestedNS(fbb);
    TableInNestedNS.addFoo(fbb, 1234);
    int nestedTableOff = TableInNestedNS.endTableInNestedNS(fbb);

    TableInFirstNS.startTableInFirstNS(fbb);
    TableInFirstNS.addFooTable(fbb, nestedTableOff);
    int off = TableInFirstNS.endTableInFirstNS(fbb);
  }

  @org.junit.Test
  public void testNestedFlatBuffer() {
    final String nestedMonsterName = "NestedMonsterName";
    final short nestedMonsterHp = 600;
    final short nestedMonsterMana = 1024;

    FlatBufferBuilder fbb1 = new FlatBufferBuilder(16);
    int str1 = fbb1.createString(nestedMonsterName);
    Monster.startMonster(fbb1);
    Monster.addName(fbb1, str1);
    Monster.addHp(fbb1, nestedMonsterHp);
    Monster.addMana(fbb1, nestedMonsterMana);
    int monster1 = Monster.endMonster(fbb1);
    Monster.finishMonsterBuffer(fbb1, monster1);
    byte[] fbb1Bytes = fbb1.sizedByteArray();
    fbb1 = null;

    FlatBufferBuilder fbb2 = new FlatBufferBuilder(16);
    int str2 = fbb2.createString("My Monster");
    int nestedBuffer = Monster.createTestnestedflatbufferVector(fbb2, fbb1Bytes);
    Monster.startMonster(fbb2);
    Monster.addName(fbb2, str2);
    Monster.addHp(fbb2, (short) 50);
    Monster.addMana(fbb2, (short) 32);
    Monster.addTestnestedflatbuffer(fbb2, nestedBuffer);
    int monster = Monster.endMonster(fbb2);
    Monster.finishMonsterBuffer(fbb2, monster);

    // Now test the data extracted from the nested buffer
    Monster mons = Monster.getRootAsMonster(fbb2.dataBuffer());
    Monster nestedMonster = mons.testnestedflatbufferAsMonster();

    Assert.assertEquals(nestedMonsterMana, nestedMonster.mana());
    Assert.assertEquals(nestedMonsterHp, nestedMonster.hp());
    Assert.assertEquals(nestedMonsterName, nestedMonster.name());
  }

  @org.junit.Test
  public void TestCreateByteVector() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(16);
    int str = fbb.createString("MyMonster");
    byte[] inventory = new byte[]{0, 1, 2, 3, 4};
    int vec = fbb.createByteVector(inventory);
    Monster.startMonster(fbb);
    Monster.addInventory(fbb, vec);
    Monster.addName(fbb, str);
    int monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject.inventory(1), (int) inventory[1]);
    Assert.assertEquals(monsterObject.inventoryLength(), inventory.length);
    ByteVector inventoryVector = monsterObject.inventoryVector();
    Assert.assertEquals(inventoryVector.getAsUnsigned(1), (int) inventory[1]);
    Assert.assertEquals(inventoryVector.length(), inventory.length);

    Assert.assertEquals(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
  }

  @org.junit.Test
  public void testCreateUninitializedVector() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(16);
    int str = fbb.createString("MyMonster");
    byte[] inventory = new byte[]{0, 1, 2, 3, 4};
    ByteBuffer bb = fbb.createUnintializedVector(1, inventory.length, 1);
    for (byte i : inventory) {
      bb.put(i);
    }
    int vec = fbb.endVector();
    Monster.startMonster(fbb);
    Monster.addInventory(fbb, vec);
    Monster.addName(fbb, str);
    int monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject.inventory(1), (int) inventory[1]);
    Assert.assertEquals(monsterObject.inventoryLength(), inventory.length);
    ByteVector inventoryVector = monsterObject.inventoryVector();
    Assert.assertEquals(inventoryVector.getAsUnsigned(1), (int) inventory[1]);
    Assert.assertEquals(inventoryVector.length(), inventory.length);
    Assert.assertEquals(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
  }

  @org.junit.Test
  public void testByteBufferFactory() {
    final class MappedByteBufferFactory extends FlatBufferBuilder.ByteBufferFactory {
      @Override
      public ByteBuffer newByteBuffer(int capacity) {
        ByteBuffer bb;
        try {
          RandomAccessFile f = new RandomAccessFile("javatest.bin", "rw");
          bb = f.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, capacity).order(ByteOrder.LITTLE_ENDIAN);
          f.close();
        } catch (Throwable e) {
          System.out.println("FlatBuffers test: couldn't map ByteBuffer to a file");
          bb = null;
        }
        return bb;
      }
    }

    FlatBufferBuilder fbb = new FlatBufferBuilder(1, new MappedByteBufferFactory());

    testBuilderBasics(fbb, false);
  }

  @org.junit.Test
  public void testSizedInputStream() {
    // Test on default FlatBufferBuilder that uses HeapByteBuffer
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);

    testBuilderBasics(fbb, false);

    InputStream in = fbb.sizedInputStream();
    byte[] array = fbb.sizedByteArray();
    int count = 0;
    int currentVal = 0;

    while (currentVal != -1 && count < array.length) {
      try {
        currentVal = in.read();
      } catch (java.io.IOException e) {
        System.out.println("FlatBuffers test: couldn't read from InputStream");
        return;
      }
      Assert.assertEquals((byte) currentVal, array[count]);
      count++;
    }
    Assert.assertEquals(count, array.length);
  }

  @org.junit.Test
  public void testVectorOfUnions() {
    final FlatBufferBuilder fbb = new FlatBufferBuilder();

    final int swordAttackDamage = 1;

    final int[] characterVector = new int[]{
      Attacker.createAttacker(fbb, swordAttackDamage),
    };

    final byte[] characterTypeVector = new byte[]{
      Character.MuLan,
    };

    Movie.finishMovieBuffer(
      fbb,
      Movie.createMovie(
        fbb,
        (byte) 0,
        (byte) 0,
        Movie.createCharactersTypeVector(fbb, characterTypeVector),
        Movie.createCharactersVector(fbb, characterVector)
      )
    );

    final Movie movie = Movie.getRootAsMovie(fbb.dataBuffer());
    ByteVector charactersTypeByteVector = movie.charactersTypeVector();
    UnionVector charactersVector = movie.charactersVector();

    Assert.assertEquals(movie.charactersTypeLength(), characterTypeVector.length);
    Assert.assertEquals(charactersTypeByteVector.length(), characterTypeVector.length);
    Assert.assertEquals(movie.charactersLength(), characterVector.length);
    Assert.assertEquals(charactersVector.length(), characterVector.length);

    Assert.assertEquals(movie.charactersType(0), characterTypeVector[0]);
    Assert.assertEquals(charactersTypeByteVector.get(0), characterTypeVector[0]);

    Assert.assertEquals(((Attacker) movie.characters(new Attacker(), 0)).swordAttackDamage(), swordAttackDamage);
  }

  @org.junit.Test
  public void TestFixedLengthArrays() {
    FlatBufferBuilder builder = new FlatBufferBuilder(0);

    float a;
    int[] b = new int[15];
    byte c;
    int[][] d_a = new int[2][2];
    byte[] d_b = new byte[2];
    byte[][] d_c = new byte[2][2];
    long[][] d_d = new long[2][2];
    int e;
    long[] f = new long[2];

    a = 0.5f;
    for (int i = 0; i < 15; i++) b[i] = i;
    c = 1;
    d_a[0][0] = 1;
    d_a[0][1] = 2;
    d_a[1][0] = 3;
    d_a[1][1] = 4;
    d_b[0] = TestEnum.B;
    d_b[1] = TestEnum.C;
    d_c[0][0] = TestEnum.A;
    d_c[0][1] = TestEnum.B;
    d_c[1][0] = TestEnum.C;
    d_c[1][1] = TestEnum.B;
    d_d[0][0] = -1;
    d_d[0][1] = 1;
    d_d[1][0] = -2;
    d_d[1][1] = 2;
    e = 2;
    f[0] = -1;
    f[1] = 1;

    int arrayOffset = ArrayStruct.createArrayStruct(builder,
      a, b, c, d_a, d_b, d_c, d_d, e, f);

    // Create a table with the ArrayStruct.
    ArrayTable.startArrayTable(builder);
    ArrayTable.addA(builder, arrayOffset);
    int tableOffset = ArrayTable.endArrayTable(builder);

    ArrayTable.finishArrayTableBuffer(builder, tableOffset);

    ArrayTable table = ArrayTable.getRootAsArrayTable(builder.dataBuffer());
    NestedStruct nested = new NestedStruct();

    Assert.assertEquals(table.a().a(), 0.5f, 0.05f);
    for (int i = 0; i < 15; i++) Assert.assertEquals(table.a().b(i), i);
    Assert.assertEquals(table.a().c(), (byte) 1);
    Assert.assertEquals(table.a().d(nested, 0).a(0), 1);
    Assert.assertEquals(table.a().d(nested, 0).a(1), 2);
    Assert.assertEquals(table.a().d(nested, 1).a(0), 3);
    Assert.assertEquals(table.a().d(nested, 1).a(1), 4);
    Assert.assertEquals(table.a().d(nested, 0).b(), TestEnum.B);
    Assert.assertEquals(table.a().d(nested, 1).b(), TestEnum.C);
    Assert.assertEquals(table.a().d(nested, 0).c(0), TestEnum.A);
    Assert.assertEquals(table.a().d(nested, 0).c(1), TestEnum.B);
    Assert.assertEquals(table.a().d(nested, 1).c(0), TestEnum.C);
    Assert.assertEquals(table.a().d(nested, 1).c(1), TestEnum.B);
    Assert.assertEquals(table.a().d(nested, 0).d(0), -1);
    Assert.assertEquals(table.a().d(nested, 0).d(1), 1);
    Assert.assertEquals(table.a().d(nested, 1).d(0), -2);
    Assert.assertEquals(table.a().d(nested, 1).d(1), 2);
    Assert.assertEquals(table.a().e(), 2);
    Assert.assertEquals(table.a().f(0), -1);
    Assert.assertEquals(table.a().f(1), 1);
  }

  @org.junit.Test
  public void TestVectorOfBytes() {
    FlatBufferBuilder fbb = new FlatBufferBuilder(16);
    int str = fbb.createString("ByteMonster");
    byte[] data = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int offset = Monster.createInventoryVector(fbb, data);
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    int monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject.inventoryLength(), data.length);
    Assert.assertEquals(monsterObject.inventory(4), (int) data[4]);
    Assert.assertEquals(ByteBuffer.wrap(data), monsterObject.inventoryAsByteBuffer());

    fbb.clear();
    ByteBuffer bb = ByteBuffer.wrap(data);
    offset = fbb.createByteVector(bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject2 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject2.inventoryLength(), data.length);
    for (int i = 0; i < data.length; i++) {
      Assert.assertEquals(monsterObject2.inventory(i), (int) bb.get(i));
    }

    fbb.clear();
    offset = fbb.createByteVector(data, 3, 4);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject3 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject3.inventoryLength(), 4);
    Assert.assertEquals(monsterObject3.inventory(0), (int) data[3]);

    fbb.clear();
    bb = ByteBuffer.wrap(data);
    offset = Monster.createInventoryVector(fbb, bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject4 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject4.inventoryLength(), data.length);
    Assert.assertEquals(monsterObject4.inventory(8), 8);

    fbb.clear();
    byte[] largeData = new byte[1024];
    offset = fbb.createByteVector(largeData);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject5 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject5.inventoryLength(), largeData.length);
    Assert.assertEquals(monsterObject5.inventory(25), (int) largeData[25]);

    fbb.clear();
    bb = ByteBuffer.wrap(largeData);
    bb.position(512);
    ByteBuffer bb2 = bb.slice();
    Assert.assertEquals(bb2.arrayOffset(), 512);
    offset = fbb.createByteVector(bb2);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject6 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject6.inventoryLength(), 512);
    Assert.assertEquals(monsterObject6.inventory(0), (int) largeData[512]);

    fbb.clear();
    bb = ByteBuffer.wrap(largeData);
    bb.limit(256);
    offset = fbb.createByteVector(bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject7 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject7.inventoryLength(), 256);

    fbb.clear();
    bb = ByteBuffer.allocateDirect(2048);
    offset = fbb.createByteVector(bb);
    str = fbb.createString("ByteMonster");
    Monster.startMonster(fbb);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, offset);
    monster1 = Monster.endMonster(fbb);
    Monster.finishMonsterBuffer(fbb, monster1);
    Monster monsterObject8 = Monster.getRootAsMonster(fbb.dataBuffer());

    Assert.assertEquals(monsterObject8.inventoryLength(), 2048);
  }

  @org.junit.Test
  public void testBuilderBasics() {

    // Second, let's create a FlatBuffer from scratch in Java, and test it also.
    // We use an initial size of 1 to exercise the reallocation algorithm,
    // normally a size larger than the typical FlatBuffer you generate would be
    // better for performance.
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);

    testBuilderBasics(fbb, true);
    testBuilderBasics(fbb, false);

    testExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());
  }

  static void testEnums() {
    Assert.assertEquals(Color.name(Color.Red), "Red");
    Assert.assertEquals(Color.name(Color.Blue), "Blue");
    Assert.assertEquals(Any.name(Any.NONE), "NONE");
    Assert.assertEquals(Any.name(Any.Monster), "Monster");
  }

  static void testMonsterBuffer(ByteBuffer bb) {
    Assert.assertTrue(Monster.MonsterBufferHasIdentifier(bb));

    Monster monster = Monster.getRootAsMonster(bb);

    Assert.assertEquals(monster.hp(), (short) 80);
    Assert.assertEquals(monster.mana(), (short) 150);  // default

    Assert.assertEquals(monster.name(), "MyMonster");
    // monster.friendly() // can't access, deprecated

    Vec3 pos = monster.pos();
    Assert.assertEquals(pos.x(), 1.0f, 0.1f);
    Assert.assertEquals(pos.y(), 2.0f, 0.1f);
    Assert.assertEquals(pos.z(), 3.0f, 0.1f);
    Assert.assertEquals(pos.test1(), 3.0, 0.1f);
    // issue: int != byte
    Assert.assertEquals(pos.test2(), (int) Color.Green);
    Test t = pos.test3();
    Assert.assertEquals(t.a(), (short) 5);
    Assert.assertEquals(t.b(), (byte) 6);

    Assert.assertEquals(monster.testType(), (byte) Any.Monster);
    Monster monster2 = new Monster();
    Assert.assertNotNull(monster.test(monster2));
    Assert.assertEquals(monster2.name(), "Fred");

    Assert.assertEquals(monster.inventoryLength(), 5);
    int invsum = 0;
    for (int i = 0; i < monster.inventoryLength(); i++)
      invsum += monster.inventory(i);
    Assert.assertEquals(invsum, 10);

    // Method using a vector access object:
    ByteVector inventoryVector = monster.inventoryVector();
    Assert.assertEquals(inventoryVector.length(), 5);
    invsum = 0;
    for (int i = 0; i < inventoryVector.length(); i++)
      invsum += inventoryVector.getAsUnsigned(i);
    Assert.assertEquals(invsum, 10);

    // Alternative way of accessing a vector:
    ByteBuffer ibb = monster.inventoryAsByteBuffer();
    invsum = 0;
    while (ibb.position() < ibb.limit())
      invsum += ibb.get();
    Assert.assertEquals(invsum, 10);

    Test test_0 = monster.test4(0);
    Test test_1 = monster.test4(1);
    Assert.assertEquals(monster.test4Length(), 2);
    Assert.assertEquals(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

    Test.Vector test4Vector = monster.test4Vector();
    test_0 = test4Vector.get(0);
    test_1 = test4Vector.get(1);
    Assert.assertEquals(test4Vector.length(), 2);
    Assert.assertEquals(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

    Assert.assertEquals(monster.testarrayofstringLength(), 2);
    Assert.assertEquals(monster.testarrayofstring(0), "test1");
    Assert.assertEquals(monster.testarrayofstring(1), "test2");

    // Method using a vector access object:
    StringVector testarrayofstringVector = monster.testarrayofstringVector();
    Assert.assertEquals(testarrayofstringVector.length(), 2);
    Assert.assertEquals(testarrayofstringVector.get(0), "test1");
    Assert.assertEquals(testarrayofstringVector.get(1), "test2");

    Assert.assertTrue(monster.testbool());
  }

  // this method checks additional fields not present in the binary buffer read from file
  // these new tests are performed on top of the regular tests
  static void testExtendedBuffer(ByteBuffer bb) {
    testMonsterBuffer(bb);

    Monster monster = Monster.getRootAsMonster(bb);

    Assert.assertEquals(monster.testhashu32Fnv1(), Integer.MAX_VALUE + 1L);
  }

  static void testBuilderBasics(FlatBufferBuilder fbb, boolean sizePrefix) {
    int[] names = {fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma")};
    int[] off = new int[3];
    Monster.startMonster(fbb);
    Monster.addName(fbb, names[0]);
    off[0] = Monster.endMonster(fbb);
    Monster.startMonster(fbb);
    Monster.addName(fbb, names[1]);
    off[1] = Monster.endMonster(fbb);
    Monster.startMonster(fbb);
    Monster.addName(fbb, names[2]);
    off[2] = Monster.endMonster(fbb);
    int sortMons = fbb.createSortedVectorOfTables(new Monster(), off);

    // We set up the same values as monsterdata.json:

    int str = fbb.createString("MyMonster");

    int inv = Monster.createInventoryVector(fbb, new byte[]{0, 1, 2, 3, 4});

    int fred = fbb.createString("Fred");
    Monster.startMonster(fbb);
    Monster.addName(fbb, fred);
    int mon2 = Monster.endMonster(fbb);

    Monster.startTest4Vector(fbb, 2);
    Test.createTest(fbb, (short) 10, (byte) 20);
    Test.createTest(fbb, (short) 30, (byte) 40);
    int test4 = fbb.endVector();

    int testArrayOfString = Monster.createTestarrayofstringVector(fbb, new int[]{
      fbb.createString("test1"),
      fbb.createString("test2")
    });

    Monster.startMonster(fbb);
    Monster.addPos(fbb, Vec3.createVec3(fbb, 1.0f, 2.0f, 3.0f, 3.0,
      Color.Green, (short) 5, (byte) 6));
    Monster.addHp(fbb, (short) 80);
    Monster.addName(fbb, str);
    Monster.addInventory(fbb, inv);
    Monster.addTestType(fbb, Any.Monster);
    Monster.addTest(fbb, mon2);
    Monster.addTest4(fbb, test4);
    Monster.addTestarrayofstring(fbb, testArrayOfString);
    Monster.addTestbool(fbb, true);
    Monster.addTesthashu32Fnv1(fbb, Integer.MAX_VALUE + 1L);
    Monster.addTestarrayoftables(fbb, sortMons);
    int mon = Monster.endMonster(fbb);

    if (sizePrefix) {
      Monster.finishSizePrefixedMonsterBuffer(fbb, mon);
    } else {
      Monster.finishMonsterBuffer(fbb, mon);
    }

    // Write the result to a file for debugging purposes:
    // Note that the binaries are not necessarily identical, since the JSON
    // parser may serialize in a slightly different order than the above
    // Java code. They are functionally equivalent though.

    try {
      String filename = "monsterdata_java_wire" + (sizePrefix ? "_sp" : "") + ".mon";
      FileChannel fc = new FileOutputStream(filename).getChannel();
      fc.write(fbb.dataBuffer().duplicate());
      fc.close();
    } catch (java.io.IOException e) {
      System.out.println("FlatBuffers test: couldn't write file");
      return;
    }

    // Test it:
    ByteBuffer dataBuffer = fbb.dataBuffer();
    if (sizePrefix) {
      Assert.assertEquals(ByteBufferUtil.getSizePrefix(dataBuffer) + SIZE_PREFIX_LENGTH,
        dataBuffer.remaining());
      dataBuffer = ByteBufferUtil.removeSizePrefix(dataBuffer);
    }
    testExtendedBuffer(dataBuffer);

    // Make sure it also works with read only ByteBuffers. This is slower,
    // since creating strings incurs an additional copy
    // (see Table.__string).
    testExtendedBuffer(dataBuffer.asReadOnlyBuffer());

    testEnums();

    //Attempt to mutate Monster fields and check whether the buffer has been mutated properly
    // revert to original values after testing
    Monster monster = Monster.getRootAsMonster(dataBuffer);

    // mana is optional and does not exist in the buffer so the mutation should fail
    // the mana field should retain its default value
    Assert.assertFalse(monster.mutateMana((short) 10));
    Assert.assertEquals(monster.mana(), (short) 150);

    // Accessing a vector of sorted by the key tables
    Assert.assertEquals(monster.testarrayoftables(0).name(), "Barney");
    Assert.assertEquals(monster.testarrayoftables(1).name(), "Frodo");
    Assert.assertEquals(monster.testarrayoftables(2).name(), "Wilma");
    Monster.Vector testarrayoftablesVector = monster.testarrayoftablesVector();
    Assert.assertEquals(testarrayoftablesVector.get(0).name(), "Barney");
    Assert.assertEquals(testarrayoftablesVector.get(1).name(), "Frodo");
    Assert.assertEquals(testarrayoftablesVector.get(2).name(), "Wilma");

    // Example of searching for a table by the key
    Assert.assertEquals(monster.testarrayoftablesByKey("Frodo").name(), "Frodo");
    Assert.assertEquals(monster.testarrayoftablesByKey("Barney").name(), "Barney");
    Assert.assertEquals(monster.testarrayoftablesByKey("Wilma").name(), "Wilma");
    Assert.assertEquals(testarrayoftablesVector.getByKey("Frodo").name(), "Frodo");
    Assert.assertEquals(testarrayoftablesVector.getByKey("Barney").name(), "Barney");
    Assert.assertEquals(testarrayoftablesVector.getByKey("Wilma").name(), "Wilma");

    // testType is an existing field and mutating it should succeed
    Assert.assertEquals(monster.testType(), (byte) Any.Monster);

    //mutate the inventory vector
    Assert.assertTrue(monster.mutateInventory(0, 1));
    Assert.assertTrue(monster.mutateInventory(1, 2));
    Assert.assertTrue(monster.mutateInventory(2, 3));
    Assert.assertTrue(monster.mutateInventory(3, 4));
    Assert.assertTrue(monster.mutateInventory(4, 5));

    for (int i = 0; i < monster.inventoryLength(); i++) {
      Assert.assertEquals(monster.inventory(i), i + 1);
    }
    ByteVector inventoryVector = monster.inventoryVector();
    for (int i = 0; i < inventoryVector.length(); i++) {
      Assert.assertEquals((int) inventoryVector.get(i), i + 1);
    }

    //reverse mutation
    Assert.assertTrue(monster.mutateInventory(0, 0));
    Assert.assertTrue(monster.mutateInventory(1, 1));
    Assert.assertTrue(monster.mutateInventory(2, 2));
    Assert.assertTrue(monster.mutateInventory(3, 3));
    Assert.assertTrue(monster.mutateInventory(4, 4));

    // get a struct field and edit one of its fields
    Vec3 pos = monster.pos();
    Assert.assertEquals(pos.x(), 1.0f, 0.1);
    pos.mutateX(55.0f);
    Assert.assertEquals(pos.x(), 55.0f, 0.1);
    pos.mutateX(1.0f);
    Assert.assertEquals(pos.x(), 1.0f, 0.1);
  }
}
